#! /usr/bin/env python
## @configure_input@

# Load settings from Python module, otherwise use install-time configururation
try:
    import lhapdf
    __version__ = lhapdf.__version__
    configured_datadir = lhapdf.paths()[0]
except ImportError:
    __version__ = '@PACKAGE_VERSION@'
    configured_datadir = '@datarootdir@/@PACKAGE_TARNAME@'.replace('${prefix}', '@prefix@')

major_version = '.'.join(__version__.split('.')[:2])
urlbase = 'http://www.hepforge.org/archive/lhapdf/pdfsets/' + major_version + '/'
index_filename = 'pdfsets.index'


import os, sys, math, optparse, textwrap, logging, csv, urllib2, tarfile, fnmatch

class Subcommand(object):
    """A subcommand of a root command-line application that may be
    invoked by a SubcommandOptionParser.
    """
    def __init__(self, name, help='', aliases=(), **kwargs):
        """Creates a new subcommand. name is the primary way to invoke
        the subcommand; aliases are alternate names. parser is an
        OptionParser responsible for parsing the subcommand's options.
        help is a short description of the command. If no parser is
        given, it defaults to a new, empty OptionParser.
        """
        self.name = name
        kwargs['add_help_option'] = kwargs.get('add_help_option', False)
        self.parser = optparse.OptionParser(**kwargs)
        if not kwargs['add_help_option']:
            self.parser.add_option('-h', '--help', action='help', help=optparse.SUPPRESS_HELP)
        self.aliases = aliases
        self.help = help

class SubcommandsOptionParser(optparse.OptionParser):
    """A variant of OptionParser that parses subcommands and their arguments."""

    # A singleton command used to give help on other subcommands.
    _HelpSubcommand = Subcommand('help',
        help='give detailed help on a specific sub-command',
        aliases=('?',))

    def __init__(self, *args, **kwargs):
        """Create a new subcommand-aware option parser. All of the
        options to OptionParser.__init__ are supported in addition
        to subcommands, a sequence of Subcommand objects.
        """
        # The subcommand array, with the help command included.
        self.subcommands = list(kwargs.pop('subcommands', []))
        self.subcommands.append(self._HelpSubcommand)

        # A more helpful default usage.
        if 'usage' not in kwargs:
            kwargs['usage'] = """
  %prog COMMAND [ARGS...]
  %prog help COMMAND"""

        # Super constructor.
        optparse.OptionParser.__init__(self, *args, **kwargs)

        # Adjust the help-visible name of each subcommand.
        for subcommand in self.subcommands:
            subcommand.parser.prog = '%s %s' % \
                    (self.get_prog_name(), subcommand.name)

        # Our root parser needs to stop on the first unrecognized argument.
        self.disable_interspersed_args()

    def add_subcommand(self, cmd):
        """Adds a Subcommand object to the parser's list of commands."""
        self.subcommands.append(cmd)

    # Add the list of subcommands to the help message.
    def format_help(self, formatter=None):
        # Get the original help message, to which we will append.
        out = optparse.OptionParser.format_help(self, formatter)
        if formatter is None:
            formatter = self.formatter

        # Subcommands header.
        result = ["\n"]
        result.append(formatter.format_heading('Commands'))
        formatter.indent()

        # Generate the display names (including aliases).
        # Also determine the help position.
        disp_names = []
        help_position = 0
        for subcommand in self.subcommands:
            name = subcommand.name
            if subcommand.aliases:
                name += ' (%s)' % ', '.join(subcommand.aliases)
            disp_names.append(name)

            # Set the help position based on the max width.
            proposed_help_position = len(name) + formatter.current_indent + 2
            if proposed_help_position <= formatter.max_help_position:
                help_position = max(help_position, proposed_help_position)

        # Add each subcommand to the output.
        for subcommand, name in zip(self.subcommands, disp_names):
            # Lifted directly from optparse.py.
            name_width = help_position - formatter.current_indent - 2
            if len(name) > name_width:
                name = "%*s%s\n" % (formatter.current_indent, "", name)
                indent_first = help_position
            else:
                name = "%*s%-*s  " % (formatter.current_indent, "",
                                      name_width, name)
                indent_first = 0
            result.append(name)
            help_width = formatter.width - help_position
            help_lines = textwrap.wrap(subcommand.help, help_width)
            result.append("%*s%s\n" % (indent_first, "", help_lines[0]))
            result.extend(["%*s%s\n" % (help_position, "", line)
                           for line in help_lines[1:]])
        formatter.dedent()

        # Concatenate the original help message with the subcommand
        # list.
        return out + "".join(result)

    def _subcommand_for_name(self, name):
        """Return the subcommand in self.subcommands matching the
        given name. The name may either be the name of a subcommand or
        an alias. If no subcommand matches, returns None.
        """
        for subcommand in self.subcommands:
            if name == subcommand.name or \
               name in subcommand.aliases:
                return subcommand
        return None

    def parse_args(self, a=None, v=None):
        """Like OptionParser.parse_args, but returns these four items:
        - options: the options passed to the root parser
        - subcommand: the Subcommand object that was invoked
        - suboptions: the options passed to the subcommand parser
        - subargs: the positional arguments passed to the subcommand
        """
        options, args = optparse.OptionParser.parse_args(self, a, v)

        if not args:
            # No command given.
            self.print_help()
            self.exit()
        else:
            cmdname = args.pop(0)
            subcommand = self._subcommand_for_name(cmdname)
            if not subcommand:
                self.error('unknown command ' + cmdname)

        suboptions, subargs = subcommand.parser.parse_args(args)

        if subcommand is self._HelpSubcommand:
            if subargs:
                # particular
                cmdname = subargs[0]
                helpcommand = self._subcommand_for_name(cmdname)
                helpcommand.parser.print_help()
                self.exit()
            else:
                # general
                self.print_help()
                self.exit()

        return options, subcommand, suboptions, subargs

class PdfSet(object):
    """Stores PDF metadata: name, version, ID code."""
    def __init__(self, name, id_code, version):
        self.name    = name
        self.id_code = id_code
        self.version = version
    def __eq__(self, other):
        if isinstance(other, PdfSet):
            return self.name == other.name
        else:
            return self.name == other
    def __ne__(self, other):
        return not self == other
    def __repr__(self):
        return self.name


def get_reference_list(filepath):
    """Reads reference file and returns list of PdfSet objects.

    The reference file is space-delimited, with columns:
    id_code version name
    """
    database = []
    try:
        csv_file = open(filepath, 'rb')
        logging.debug('Reading %s' % filepath)
        reader = csv.reader(csv_file, delimiter=' ', skipinitialspace=True, strict=True)
        for row in reader:
            # TODO: Add PDF versioning in LHAPDF 6.1
            #if len(row) != 3:
                #raise ValueError
            #id_code, version, name = int(row[0]), int(row[1]), str(row[2])
            if len(row) != 2:
                raise ValueError
            id_code, version, name = int(row[0]), None, str(row[1])
            database.append(PdfSet(name, id_code, version))
    except IOError:
        logging.error('Could not open %s' % filepath)
    except (ValueError, csv.Error):
        logging.error('Corrupted file on line %d: %s' % (reader.line_num, filepath))
        csv_file.close()
        database = []
    else:
        csv_file.close()
    return database


def get_installed_list(path):
    """Returns list of PdfSet objects representing PDFs installed in 'path'.

    The path to each YAML file is assumed to be:
    path/pdf_name/pdf_name.info
    """
    if not os.path.isdir(path):
        logging.error('Unable to find directory %s' % path)
        return []

    version_fieldname = 'DataVersion'

    database = []
    for subdir in os.listdir(path):
        metadata_filepath = os.path.join(path, subdir, subdir + os.extsep + 'info')
        if os.path.isfile(metadata_filepath):
            try:
                metadata_file = open(metadata_filepath, 'rb')
                logging.debug('Reading %s' % metadata_filepath)

                # Attempt to find PDF version from YAML file
                for line in metadata_file:
                    if version_fieldname in line:
                        version = int(line.split(version_fieldname, 1)[1].split(':', 1)[1].strip())
                        break
                else:
                    version = None

                name = subdir
                database.append(PdfSet(name, 0, version))
            except IOError:
                logging.error('Could not open %s' % metadata_filepath)
            except ValueError:
                logging.error('Corrupted file %s' % metadata_filepath)
                metadata_file.close()
            else:
                metadata_file.close()
    return database


def download_file(url, dest_dir, dryrun=False):
    """Download a file from url to destination directory."""
    if not os.path.isdir(os.path.abspath(dest_dir)):
        logging.info('Creating directory %s' % dest_dir)
        os.makedirs(dest_dir)

    dest_filepath = os.path.join(dest_dir, os.path.basename(url))

    try:
        u = urllib2.urlopen(url)
        file_size = int(u.info().getheaders('Content-Length')[0])
    except urllib2.URLError, e:
        logging.error('Unable to download %s' % url)
        return False

    logging.debug('Downloading from %s' % url)
    logging.debug('Downloading to %s' % dest_filepath)
    if dryrun:
        logging.info('%s [%s]' % (os.path.basename(url), convertBytes(file_size)))
        return False

    try:
        dest_file = open(dest_filepath, 'wb')
    except IOError:
        logging.error('Could not write to %s' % dest_filepath)
        return False

    try:
        try:
            file_size_dl = 0
            buffer_size  = 8192
            while True:
                buffer = u.read(buffer_size)
                if not buffer: break

                file_size_dl += len(buffer)
                dest_file.write(buffer)

                status  = chr(13) + '%s: ' % os.path.basename(url)
                status += r'%s [%3.1f%%]' % (convertBytes(file_size_dl).rjust(10), file_size_dl * 100. / file_size)
                print status,
        except urllib2.URLError, e:
            logging.error('Error during download: ', e.reason)
            return False
        except KeyboardInterrupt:
            logging.error('Download halted by user')
            return False
    finally:
        dest_file.close()
        print

    return True


def convertBytes(size, nDecimalPoints=1):
    units = ('B', 'KB', 'MB', 'GB')
    i = int(math.floor(math.log(size, 1024)))
    p = math.pow(1024, i)
    s = round(size/p, nDecimalPoints)
    if (s > 0):
        return '%s %s' % (s, units[i])
    else:
        return '0 B'


if __name__ == '__main__':
    #######################
    #  Setup subcommands  #
    #######################
    pattern_match_desc = ' Supports Unix-style pattern matching of PDF names.'

    update_cmd = Subcommand('update',
        description='Update the list of available PDF sets.',
        help='update list of available PDF sets')

    list_cmd = Subcommand('list', aliases=('ls',), usage='%prog [options] pattern...',
        description='List all available PDF sets, or search using a pattern.' + pattern_match_desc,
        help='list installed/available PDF sets')
    list_cmd.parser.add_option('--installed', action='store_true',
        help='list installed PDF sets')
    list_cmd.parser.add_option('--outdated', action='store_true',
        help='list installed, but outdated, PDF sets')
    list_cmd.parser.add_option('--codes', action='store_true',
        help='additionally show ID codes')

    install_cmd = Subcommand('install', aliases=('get',), usage='%prog [options] pattern...',
        description='Download and unpack a list of PDFs, or those matching a pattern.' + pattern_match_desc,
        help='install PDF sets')
    install_cmd.parser.add_option('--dryrun', action='store_true',
        help='Do not download sets')
    install_cmd.parser.add_option('--upgrade', action='store_true',
        help='Force reinstall (used to upgrade)')

    #####################################
    #  Setup global parser and options  #
    #####################################
    parser = SubcommandsOptionParser(
        description = 'LHAPDF is an interface to parton distribution functions. This program is intended for browsing and installing the PDFs.',
        version     = __version__,
        subcommands = (update_cmd, list_cmd, install_cmd)
    )
    parser.add_option('-q', '--quiet', help='Suppress normal messages',
        dest='LOGLEVEL', action='store_const', const=logging.WARNING, default=logging.INFO)
    parser.add_option('-v', '--verbose', help='Output debug messages',
        dest='LOGLEVEL', action='store_const', const=logging.DEBUG, default=logging.INFO)
    parser.add_option('--listdir', default=configured_datadir,
        help='PDF list directory [default: %default]')
    parser.add_option('--pdfdir', default=configured_datadir,
        help='PDF sets directory [default: %default]')

    ##############################
    #  Parse command-line input  #
    ##############################
    options, subcommand, suboptions, subargs = parser.parse_args()
    logging.basicConfig(level=options.LOGLEVEL, format='%(levelname)s: %(message)s')
    if subcommand is list_cmd:
        if suboptions.installed and suboptions.outdated:
            subcommand.parser.error("Options '--installed' and '--outdated' are mutually exclusive")



    # Update command doesn't depend on PDF sets
    if subcommand is update_cmd:
        download_file(urlbase + index_filename, options.listdir)
        sys.exit(0)


    # List and install commands require us to build lists of reference and installed PDFs
    master_list, installed = {}, {}
    for pdf in get_reference_list(os.path.join(options.listdir, index_filename)):
        master_list[pdf.name] = pdf
    for pdf in get_installed_list(options.pdfdir):
        installed[pdf.name] = pdf

    # Check installation status of all PDFs
    for pdf in master_list.keys():
        master_list[pdf].installed = pdf in installed
        if pdf not in installed or installed[pdf].version is None or master_list[pdf].version is None:
            master_list[pdf].outdated = False
        else:
            master_list[pdf].outdated = installed[pdf].version < master_list[pdf].version

    # Unix-style pattern matching of arguments
    search_pdfs = []
    for pattern in subargs:
        matched_pdfs = fnmatch.filter(master_list.keys(), pattern)
        if len(matched_pdfs) == 0:
            logging.warning('No matching PDFs for pattern: %s' % pattern)
        else:
            search_pdfs += matched_pdfs


    if subcommand is list_cmd:
        # No patterns given => use all PDFs
        if len(subargs) == 0:
            search_pdfs = master_list.keys()

        if suboptions.installed:
            displayed_pdfs = [pdf for pdf in search_pdfs if master_list[pdf].installed]
        elif suboptions.outdated:
            displayed_pdfs = [pdf for pdf in search_pdfs if master_list[pdf].outdated]
        else:
            displayed_pdfs = search_pdfs

        for pdf in sorted(displayed_pdfs):
            if suboptions.codes:
                print '%d  %s' % (master_list[pdf].id_code, pdf)
            else:
                print pdf
        sys.exit(0)


    if subcommand is install_cmd:
        for pdf in sorted(search_pdfs):
            if pdf not in master_list:
                logging.warn('PDF not recognised: %s' % pdf)
                continue
            if pdf in installed and not suboptions.upgrade:
                logging.warn('PDF already installed: %s (use --upgrade to force install)' % pdf)
                continue

            tar_filename = pdf + '.tar.gz'
            if download_file(urlbase + tar_filename, options.pdfdir, dryrun=suboptions.dryrun):
                try:
                    tar_file = tarfile.open(os.path.join(options.pdfdir, tar_filename), 'r:gz')
                    tar_file.extractall(options.pdfdir)
                    tar_file.close()
                except:
                    logging.error('Unable to extract %s' % tar_filename)
